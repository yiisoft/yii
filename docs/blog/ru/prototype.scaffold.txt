Генерация каркаса
=================

Create, read, update и delete (CRUD) — четыре основных операции, при помощи
которых можно управлять объектами данных. Так как реализация CRUD является
типичной задачей для любого веб-приложения, для автоматизации можно воспользоваться
специальными инструментами для генерации кода *Gii* (также известным как *скаффолдинг*).

> Note|Примечание: Gii доступен начиная с версии 1.1.2. До этого мы бы использовали
[yiic shell](/doc/guide/ru/quickstart.first-app-yiic).

Далее мы опишем как использовать данный инструмент для реализации операций CRUD
записей и комментариев нашего блога.

Установка Gii
-------------

Для начала необходимо установить Gii. Открываем файл
`/wwwroot/blog/protected/config/main.php` и добавляем следующее:

~~~
[php]
return array(
	......
	'import'=>array(
		'application.models.*',
		'application.components.*',
	),

	'modules'=>array(
		'gii'=>array(
			'class'=>'system.gii.GiiModule',
			'password'=>'ваш пароль',
		),
	),
);
~~~

Код выше включает модуль с именем `gii`, который позволяет нам использовать
Gii по следующему URL:

~~~
http://www.example.com/blog/index.php?r=gii
~~~

Будет запрошен пароль, который мы указали в
`/wwwroot/blog/protected/config/main.php`. После этого будет показана страница
со всеми доступными инструментами генерации кода.

> Note|Примечание: Код, приведённый выше не должен попасть на сервер.
Инструменты для генерации кода должны использоваться только при разработке.


Создание моделей
----------------

Для начала нам необходимо создать [классы моделей](/doc/guide/ru/basics.model)
для каждой из таблиц в БД. Эти классы позволят нам работать с БД в стиле ООП,
что будет показано далее в данном руководстве.

Запускаем `Model Generator`. На странице вводим `tbl_user` (имя таблицы,
хранящей пользователей) в поле `Table Name`, `tbl_` в поле `Table Prefix` и нажимаем кнопку `Preview`.
Будет показана таблица, ссылки в которой позволят просмотреть код, который мы
собираемся сгенерировать. Если всё в порядке, можно нажимать `Generate`. При этом
код будет сохранён в файл.

> Info|Информация: Так как генератору кода необходимо сохранить код в файлы,
процесс должен иметь права на создание и изменение соответствующих файлов.
Проще всего дать процессу права на запись во всю директорию `/wwwroot/blog`.
Стоит отметить, что это требуется сделать только на машине разработчика
при использовании `Gii`.

Повторим те же действия для всех остальных таблиц БД, включая
`tbl_post`, `tbl_comment`, `tbl_tag` и `tbl_lookup`.

> Tip|Подсказка: Также мы можем ввести `*` в поле `Table Name`. Так мы сгенерируем
модели для *каждой* таблицы БД за один раз.

На данном этапе у нас будут созданы следующие файлы:

  * `models/User.php` содержит класс `User`, который наследуется от
  [CActiveRecord] и может использоваться для обращения к таблице `tbl_user`;
  * `models/Post.php` содержит класс `Post`, который наследуется от
  [CActiveRecord] и может использоваться для обращения к таблице `tbl_post`;
  * `models/Tag.php` содержит класс `Tag`, который наследуется от
  [CActiveRecord] и может использоваться для обращения к таблице `tbl_tag`;
  * `models/Comment.php` содержит класс `Comment`, который наследуется от
  [CActiveRecord] и может использоваться для обращения к таблице `tbl_comment`;
  * `models/Lookup.php` содержит класс `Lookup`, который наследуется от
  [CActiveRecord] и может использоваться для обращения к таблице `tbl_lookup`.

Реализация операций CRUD
------------------------

После того, как были созданы классы модели, мы можем использовать `Crud Generator`
для генерации кода операций CRUD для них. Сделаем это для моделей `Post` и `Comment`.

На странице `Crud Generator` введём `Post` (имя модели записи блога, которую мы
создали ранее) в поле `Model Class` и нажмём `Preview`, а затем `Generate`.

Повторим эти же действия для модели `Comment`.

Рассмотрим сгенерированные файлы в `/wwwroot/blog/protected`. Для удобства
сгруппируем их в [файлы контроллеров](/doc/guide/ru/basics.controller) и
[файлы представлений](/doc/guide/ru/basics.view):

 - файлы контроллеров:
  * `Controllers/PostController.php` содержит класс `PostController`, который
  является контроллером, отвечающим за все операции CRUD для записей;
  * `Controllers/CommentController.php` содержит класс `CommentController`,
  который является контроллером, отвечающим за все операции CRUD для комментариев;

 - файлы представлений:
  * `views/post/create.php` — файл представления, который показывает HTML-форму
     для создания записи;
  * `views/post/update.php` — файл представления, который показывает HTML-форму
     для обновления записи;
  * `views/post/view.php` — файл представления, который отображает подробную
     информацию записи;
  * `views/post/index.php` — файл представления, который отображает список записей;
  * `views/post/admin.php`— файл представления, который отображает записи в
     таблице с административными командами.
  * `views/post/_form.php` — частичный файл представления, используемый в
    `views/post/create.php` и `views/post/update.php`. Он отображает
     HTML-форму для сбора информации о записи.
  * `views/post/_view.php` — частичный файл представления, используемый в
    `views/post/index.php`. Он отображает краткий вид отдельной записи.
  * `views/post/_search.php`— файл представления, используемый в `views/post/admin.php`.
     Используется для формы поиска.
  * Подобный набор файлов представлений также сгенерирован для комментариев.

Тестирование
------------

Мы можем проверить работу сгенерированного кода, используя следующие URL:

~~~
http://www.example.com/blog/index.php?r=post
http://www.example.com/blog/index.php?r=comment
~~~

Стоит отметить, что возможности по управлению записями и комментариями полностью
независимы. Также, при создании новой записи или комментария необходимо вводить
такие данные, как `author_id` и `create_time`, что в реальном приложении должно
делаться автоматически. Не беспокойтесь, мы исправим эти проблемы далее.
На данный момент прототип уже содержит большинство возможностей, необходимых
нашему блогу.

Чтобы лучше понять, как используются файлы выше, рассмотрим, что происходит
при отображении списка записей:

 0. Пользователь запрашивает URL `http://www.example.com/blog/index.php?r=post`;
 1. [Входной скрипт](/doc/guide/ru/basics.entry) выполняется Web-сервером и инициализирует экземпляр
    [приложения](/doc/guide/ru/basics.application) для обработки запроса;
 2. Приложение создает экземпляр класса `PostController` и выполняет его;
 3. Экземпляр класса `PostController` выполняет действие `index` (метод `actionIndex()`).
    Отметим, что `index` является действием по умолчанию и используется в случае,
    если пользователь не указал действие в URL;
 4. Метод `actionIndex()` делает запрос к базе данных для получения списка последних записей;
 5. Метод `actionIndex()` генерирует представление `index` с данными записей.