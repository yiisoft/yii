Доработка модели Post
=====================

Модель `Post`, сгенерированная при помощи `yiic`, нуждается в следующих изменениях:

 - метод `rules()`: задаёт правила валидации атрибутов модели;
 - метод `relations()`: задаёт отношения с связанными объектами.

> Info|Информация: [Модель](/doc/guide/ru/basics.model) состоит из набора атрибутов,
  каждый из которых ассоциируется с соответствующим полем в таблице БД.
  Атрибуты могут быть описаны явно как переменные класса, либо использоваться без
  какого-либо описания.

Помните, что если вы используете Yii версии 1.0.x, то должны также изменить
метод `safeAttributes()`, который объявляет список атрибутов, чьи значения
могут быть приняты пакетно из данных, введенных пользователем. С версии 1.1.0,
такое изменение больше не требуется, так как безопасные атрибуты определяются
правилом валидации, объявленном в методе `rules()`.


Изменение метода `rules()`
--------------------------

В первую очередь необходимо определить правила валидации, которые позволят
убедится в том, что данные, полученные от пользователя корректны до их вставки в БД.
К примеру, атрибут `status` модели `Post` должен быть целым числом, равным 0, 1 или 2.
Консоль `yiic` генерирует правила валидации для каждой модели. При этом
используется структура БД, поэтому некоторые правила могу оказаться неточными.

Основываясь на анализе требований, изменим метод `rules()` следующим образом:

~~~
[php]
public function rules()
{
	return array(
		array('title, content, status', 'required'),
		array('title', 'length', 'max'=>128),
		array('status', 'in', 'range'=>array(0, 1, 2)),
		array('tags', 'match', 'pattern'=>'/^[\w\s,]+$/',
			'message'=>'В тегах можно использовать только буквы.'),
	);
}
~~~

В коде выше мы определили, что атрибуты `title`, `content` и `status` являются
обязательными для заполнения. Длина `title` не должна превышать 128 символов.
Значение `status` может быть 0 (черновик), 1 (опубликовано) или 2 (в архиве).
В `tags` могут содержаться только буквы, запятые и пробелы. Все остальные
атрибуты (`id`, `createTime` и т.д.) не будут валидироваться т.к. их значения
пользователь не задаёт.

После того, как мы сделали описанные изменения, мы можем зайти на страницу
создания записи и проверить, что новые правила валидации работают.

> Info|Информация: Правила валидации используются при вызове методов модели
[validate()|CModel::validate] или [save()|CActiveRecord::save]. За более
подробной информацией о правилах валидации обратитесь к
[полному руководству](/doc/guide/ru/form.model#declaring-validation-rules).


Изменение метода `relations()`
------------------------------

Далее укажем в методе `relations()` связанные с записью объекты. После этого мы
сможем использовать [реляционную ActiveRecord (RAR)](/doc/guide/ru/database.arr)
для получения связанных с записью данных, таких как информацию об авторе и
комментарии. Сложные SQL запросы с JOIN в этом случае не потребуются.

Определим метод `relations()`:

~~~
[php]
public function relations()
{
	return array(
		'author'=>array(self::BELONGS_TO, 'User', 'authorId'),
		'comments'=>array(self::HAS_MANY, 'Comment', 'postId',
			'order'=>'comments.createTime'),
		'tagFilter'=>array(self::MANY_MANY, 'Tag', 'PostTag(postId, tagId)',
			'together'=>true,
			'joinType'=>'INNER JOIN',
			'condition'=>'tagFilter.name=:tag'),
	);
}
~~~

Выше описано следующее:

 * Запись принадлежит автору(`User`), связь с которым устанавливается на основе
   поля записи `authorId`;
 * Запись может содержать много комментариев(`Comment`), связь с которыми
   устанавливается на основе поля комменария `postId`. Комментарии сортируются по
   времени их создания.

Отношение `tagFilter` немного сложнее. Оно используется для явного пересечения
таблицы `Post` с таблицей `Tag` и выбора только строк с определённым тегом. Мы
покажем, как использовать это отношение, когда будем реализовывать отображение
записей.

Задав описанные выше отношения, мы можем получить информацию об авторе и
комментариях к записи следующим образом:

~~~
[php]
$author=$post->author;
echo $author->username;

$comments=$post->comments;
foreach($comments as $comment)
	echo $comment->content;
~~~

Более подробно использование и определение отношений описано в
[полном руководстве](/doc/guide/ru/database.arr).

Текстовое представление для статуса
-----------------------------------

Так как статус записи хранится в БД в виде числа, нам необходимо получить его
текстовое представление для отображения пользователям. Для этого дополним
модель `Post`:

~~~
[php]
class Post extends CActiveRecord
{
	const STATUS_DRAFT=0;
	const STATUS_PUBLISHED=1;
	const STATUS_ARCHIVED=2;

	......

	public function getStatusOptions()
	{
		return array(
			self::STATUS_DRAFT=>'Черновик',
			self::STATUS_PUBLISHED=>'Опубликовано',
			self::STATUS_ARCHIVED=>'В архиве',
		);
	}

	public function getStatusText()
	{
		$options=$this->statusOptions;
		return isset($options[$this->status]) ? $options[$this->status]
			: "unknown ({$this->status})";
	}
}
~~~

В приведённом коде мы определили константы класса для представления возможных
значений статуса. Эти константы используются для улучшения читаемости кода.
Был определён метод `getStatusOptions()`, возвращающий соответствия
числовых значений статуса и его текстовых представлений. Также мы реализовали
метод `getStatusText()`, который возвращает текстовое представление статуса
текущей записи.

<div class="revision">$Id: post.model.txt 1495 2009-10-29 17:24:41Z qiang.xue $</div>
