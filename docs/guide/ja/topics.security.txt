セキュリティ
========

クロスサイトスクリプティングの防止
-------------------------------
クロスサイトスクリプティング（XSS としても良く知られます）は
ウェブアプリケーションが悪意のあるデータをユーザから回収した時に
引き起こされます。攻撃者は度々、他のアプリケーションユーザを弄び
彼らからデータを収集する為に、JavaScript、VBScript、ActiveX、HTML、
或いはFlashを攻撃されやすいアプリケーションの中へ注入します。例えば、
貧弱にデザインされたフォーラムのシステムは、ユーザのフォーラムへの
投稿の入力を全くチェックする事なく表示するでしょう。この時、
攻撃者は悪意のあるJavaScriptのコードのかけらを投稿へ注入し、
他のユーザ達がこの投稿を読んだ時、JavaScriptは彼らのコンピュータ
の中で突然動き出すのです。

XSS攻撃に他する防御の、もっとも重要な手段の一つは、ユーザからの入力
を表示する前にチェックする事です。これを成し遂げる為に、HTMLエンコーディング
を施す人も居るでしょう。しかしながら、HTMLエンコーディングは全てのHTMLタグ
を使えなくしてしまう為、これが望ましくない状況もあるでしょう。

Yiiは[HTMLPurifier](http://htmlpurifier.org/) の働きに賛同し、
[CHtmlPurifier] という、[HTMLPurifier](http://htmlpurifier.org/) 
を包み込んだ便利なコンポーネントを開発者へ供給します。このコンポーネント
は全ての悪意のあるコードを徹底的に検査して取り除く事に役立ち、
許可されたホワイトリストの使用や、コンテンツのフィルタリングの確認
といった標準に準拠しているのでとても安全です。

[CHtmlPurifier] コンポーネントは、[widget](/doc/guide/basics.view#widget)
としても[filter](/doc/guide/basics.controller#filter)としても使用可能です。
ウィジェットとして使用した場合、[CHtmlPurifier] は
ビューのボディーに表示されたコンテンツから不純物を取り除くでしょう。
例えば、

~~~
[php]
<?php $this->beginWidget('CHtmlPurifier'); ?>
...ここへユーザが入力したコンテンツが表示されます...
<?php $this->endWidget(); ?>
~~~


クロスサイトリクエストフォージェリの阻止
-------------------------------------

クロスサイトリクエストフォージェリ(CSRF)による攻撃は、
悪意のあるウェブサイトが、ユーザのブラウザに対して、
信頼済みのサイトへ望んでないアクションを行わせる事で引き起こされます。
例えば、悪意のあるウェブサイトがイメージタグを含んでいて、その`src`が、
オンラインバンクのサイトの
`http://bank.example/withdraw?transfer=10000&to=someone` 
になっているとします。もしユーザが、オンラインバンキングへ
ログインした状態のクッキーを持っていて、この悪意のあるコードを含んだサイト
を訪れた場合、someone へ10000ドル送金(transfer)するアクション
が引き起こされるでしょう。CSRFは、狙ったクロスサイトに対して
ユーザが持っていた信頼を利用し、そのサイトがユーザに対して
持っていた信頼を利用するのです。

CSRF攻撃を防ぐには、`GET` リクエストがデータの取得にのみ許可され、
一切のサーバーのデータを変更する事が出来ないというルール
に従う事が重要です。そして `POST` リクエストについては、
フォームによるリクエストの送信者と、サーバーが結果を送る相手が
同一である事を認識出来るようにする為の、いくつかのランダムな値
を保有させるべきです。

Yiiは、`POST` によるCSRF攻撃を防ぐスキーマを実装しています。
これは、ランダムな値をクッキーに保存し、`POST` リクエストによって
送信された値と比較する事で成り立っています。

初期状態では、CSRFに対する防御は無効になっています。有効にするには 
[application configuration](/doc/guide/basics.application#application-configuration) 
の中で[CHttpRequest] コンポーネントを下記の様に設定して下さい。

~~~
[php]
return array(
	'components'=>array(
		'request'=>array(
			'enableCsrfValidation'=>true,
		),
	),
);
~~~

そしてフォームを表示するには、HTMLフォームのタグを直接書く代わりに、
[CHtml::form] をコールします。[CHtml::form] メソッドは hidden 
フィールドに必要なランダムな値を含んでいるので、これをCSRFバリデーション
として送信させる事ができます。


クッキー攻撃の防止
------------------------
セッションIDがクッキーに含まれている場合、クッキーを攻撃から守る事は、
とてつもなく大切です。もし誰かがセッションIDを手中に収めた場合、
彼はセッションに関連する全ての情報を手に入れた事になります。

クッキーを攻撃から守る為のいくつかの対策があります。

* アプリケーションはSSLを使う事で、安全なコミュニケーションチャンネルを作り
HTTPS接続による認証クッキーのみを通す様にする事が出来ます。
攻撃者はこれによって送信されたクッキーの内容を解読することが出来ません。

* 全てのクッキーとセッションに対して、セッションを適切な有効期限内で打ち切る
様にし、攻撃される可能性を減少させます。
* 任意のコードがユーザのブラウザで動作して、クッキーを危険に晒す
クロスサイトスクリプティング を防ぎます。
* クッキーのデータを検証し、改変を検出する様にします。

Yiiはクッキーバリデーションスキーマを実装し、クッキーが改変される事
を防ぎます。具体的には、もしクッキーバリデーションが有効なら、
クッキーの値に対してHMACチェック行います。

クッキーバリデーションは初期状態では無効になっています。有効にするには、
[application configuration](/doc/guide/basics.application#application-configuration)
の中の [CHttpRequest] アプリケーションコンポーネントを下記の様に設定します。

~~~
[php]
return array(
	'components'=>array(
		'request'=>array(
			'enableCookieValidation'=>true,
		),
	),
);
~~~

Yiiによって供給されるクッキーバリデーションの使用では、 `$_COOKIES` 
に直接アクセスする代わりに、[cookies|CHttpRequest::cookies] 
コレクションを通してクッキーにアクセスする必要があります。

~~~
[php]
// 特定の名前のクッキーを取得します。
$cookie=Yii::app()->request->cookies[$name];
$value=$cookie->value;
......
// クッキーを送ります。
$cookie=new CHttpCookie($name,$value);
Yii::app()->request->cookies[$name]=$cookie;
~~~


<div class="revision">$Id: topics.security.txt 2535 2010-10-11 08:28:08Z mdomba $</div>