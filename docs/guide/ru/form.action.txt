Создание действия
=================

Теперь, когда готова модель, можно приступать к написанию кода для работы с ней.
Всю логику обработки мы помещаем в действие контроллера. Для формы
авторизации, например, нам потребуется следующий код:

~~~
[php]
public function actionLogin()
{
	$model=new LoginForm;
	if(isset($_POST['LoginForm']))
	{
		// получаем данные от пользователя
		$model->attributes=$_POST['LoginForm'];
		// проверяем полученные данные и, если результат проверки положительный,
		// перенаправляем пользователя на предыдущую страницу
		if($model->validate())
			$this->redirect(Yii::app()->user->returnUrl);
	}
	// рендерим представление
	$this->render('login',array('model'=>$model));
}
~~~

Вначале мы создаём экземпляр модели `LoginForm`, затем, если данные формы были
отправлены, заполняем `$model` данными `$_POST['LoginForm']`. Далее проверяем
полученные данные и, если ошибок нет, перенаправляем пользователя на страницу,
для доступа к которой требовалось авторизоваться, т.е. ту страницу, которая
отправила пользователя на страницу авторизации. Если же результат проверки
отрицательный или действие выполняется впервые, то отображаем пользователю
представление `login`, которое рассмотрим в следующем разделе.

> Tip|Подсказка: В действии `login` мы используем `Yii::app()->user->returnUrl`,
чтобы получить URL страницы, которая затребовала авторизацию. Компонент `Yii::app()->user`
является объектом класса [CWebUser] (или его производного), который позволяет получить информацию, хранящуюся в сессии
пользователя (например, имя пользователя, статус и пр.). Подробно ознакомиться с этой темой можно
в разделе [Аутентификация и авторизация](/doc/guide/topics.auth).

Обратим особое внимание на следующее выражение в действии `login`:

~~~
[php]
$model->attributes=$_POST['LoginForm'];
~~~

Как мы уже говорили в подразделе [Безопасное присваивание значений атрибутам](/doc/guide/form.model#securing-attribute-assignments),
это выражение заполняет модель данными, которые ввёл пользователь. Свойство `attributes` определяется
классом [CModel], который ожидает получить массив пар имя-значение, чтобы затем присвоить каждому атрибуту модели
соответствующее значение. Следовательно, если `$_POST['LoginForm']` содержит такой массив, то выражение,
которое мы привели выше, будет эквивалентно следующему коду (считаем, что массив содержит все нужные нам атрибуты):

~~~
[php]
$model->username=$_POST['LoginForm']['username'];
$model->password=$_POST['LoginForm']['password'];
$model->rememberMe=$_POST['LoginForm']['rememberMe'];
~~~

> Note|Примечание: Для того чтобы `$_POST['LoginForm']` возвращал массив вместо строки,
необходимо следовать правилам именования полей ввода в представлении. Так, поле, соответствующее
атрибуту `a` в классе модели `C`, должно называться `C[a]`. В нашем примере в качестве имени поля формы, соответствующего
атрибуту `username`, мы будем использовать `LoginForm[username]`.

Теперь нам осталось только создать представление `login`, которое будет содержать
HTML форму с требуемыми полями.

<div class="revision">$Id: form.action.txt 1837 2010-02-24 22:49:51Z qiang.xue $</div>