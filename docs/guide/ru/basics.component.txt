Компонент
=========
Yii-приложения состоят из компонентов–объектов, созданных согласно спецификациям.
Компонент (component) — это экземпляр класса [CComponent] или производного от него.
Использование компонента в основном включает доступ к его свойствам, а также вызов и обработку его событий.
Базовый класс [CComponent] устанавливает то, как определяются свойства и события.

Свойство компонента
-------------------
Свойство компонента схоже с публичной переменной-членом класса (public member variable).
Мы можем читать или устанавливать его значение. Например:

~~~
[php]
$width=$component->textWidth; // получаем значение свойства textWidth
$component->enableCaching=true; // устанавливаем значение свойства enableCaching
~~~

Для того, чтобы создать свойство компонента необходимо просто объявить публичную переменную в классе компонента.
Более гибкий вариант — определить методы, считывающие (getter) и записывающие (setter) это
свойство, например:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

В приведенном коде определено свойство `textWidth` (имя нечувствительно к регистру), доступное для записи.

При чтении вызывается метод чтения `getTextWidth()`, возвращающий значение свойства.
Соответственно, при записи будет вызван метод записи `setTextWidth()`.
Если метод записи не определен, свойство будет доступно только для чтения, а
при попытке записи будет вызвано исключение. Использование методов чтения и
записи имеет дополнительное преимущество: при чтении или записи значения
свойства могут быть выполнены дополнительные действия (такие как проверка на корректность,
вызов события и др.).

>Note|Примечание: Есть небольшая разница в определении свойства через методы и через простое
объявление переменной. В первом случае имя свойства нечувствительно к регистру,
во втором — чувствительно.


События компонента
------------------
События компонента — это специальные свойства, в качестве значений которых выступают
методы (называемые обработчиками событий). Назначение метода событию приведет к тому, что метод будет вызван
автоматически при возникновении этого события. Поэтому поведение компонента может быть
изменено совершенно отлично от закладываемого при разработке.

Событие компонента объявляется путем создания метода с именем, начинающимся на `on`.
Также, как и имена свойств, заданных через методы чтения и записи, имена событий
не чувствительны к регистру. Следующий код объявляет событие `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raiseEvent('onClicked', $event);
}
~~~

где `$event` — это экземпляр класса [CEvent] или производного от него,
представляющего параметр события. К событию можно подключить обработчик, как показано ниже:

~~~
[php]
$component->onClicked=$callback;
~~~

где `$callback` — это корректный callback-вызов PHP (см.
PHP-функцию call_user_func). Это может быть либо глобальная функция, либо метод класса.
В последнем случае вызову должен передаваться массив: `array($object,'methodName')`.

Обработчик события должен быть определен следующим образом:

~~~
[php]
function methodName($event)
{
    …
}
~~~

где `$event` — это параметр, описывающий событие (происходит из вызова `raiseEvent()`).
Параметр `$event` — это экземпляр класса [CEvent] или его производного.
Как минимум, он содержит информацию о том, кто вызвал событие.

Обработчик события может быть анонимной функцией,
требующей наличия версии PHP 5.3+. Например,

~~~
[php]
$component->onClicked=function($event) {
	…
}
~~~

Если теперь использовать метод `onClicked()`, то в нём будет вызвано событие `onClicked`.
Назначенный ему обработчик будет запущен автоматически.

Событию могут быть назначены несколько обработчиков.
При возникновении события обработчики будут вызваны в порядке их назначения.
Если в обработчике необходимо предотвратить вызов последующих обработчиков,
необходимо установить [$event->handled|CEvent::handled] в `true`.


Поведения и компонент
---------------------

Для компонент реализован шаблон проектирования [mixin](http://en.wikipedia.org/wiki/Mixin),
что позволяет присоединить к ним одно или несколько поведений. *Поведение* —
объект, чьи методы «наследуются» компонентом, к которому они присоединены. Под
«наследованием» здесь понимается наращивание функционала, а не наследование
в классическом смысле. К компоненту можно прикрепить несколько поведений и,
таким образом, получить множественное наследование.

Поведение классов должно реализовывать интерфейс [IBehavior]. Большинство поведений могут быть созданы путем расширения
базового класса [CBehavior]. В случае, если поведение необходимо прикрепить к [модели](/doc/guide/basics.model), его можно
создать на основе класса [CModelBehavior] или класса [CActiveRecordBehavior], который реализует дополнительные,
специфические для модели возможности.

Чтобы воспользоваться поведением, его необходимо прикрепить к компоненту путем вызова метода поведения
[attach()|IBehavior::attach]. Далее мы вызываем метод поведения через компонент:

~~~
[php]
// $name уникально идентифицирует поведения в компоненте
$component->attachBehavior($name,$behavior);
// test() является методом $behavior
$component->test();
~~~

К прикрепленному поведению можно обращаться, как к обычному свойству компонента.
Например, если поведение с именем `tree` прикреплено к компоненту, мы можем получить
ссылку на этот объект поведения следующим образом:

~~~
[php]
$behavior=$component->tree;
// эквивалентно выражению:
// $behavior=$component->asa('tree');
~~~

Поведение можно временно деактивировать таким образом, чтобы его методы были недоступны через компонент.
Например:

~~~
[php]
$component->disableBehavior($name);
// выражение ниже приведет к вызову исключения
$component->test();
$component->enableBehavior($name);
// здесь все будет работать нормально
$component->test();
~~~

В случае, когда два поведения, прикрепленные к одному компоненту, имеют методы с одинаковыми именами,
преимущество будет иметь метод поведения, которое было прикреплено раньше.

Использование поведений совместно с [событиями](/doc/guide/basics.component#component-event) дает дополнительные возможности.
Поведение, прикрепленное к компоненту, может присваивать некоторые свои методы событиям компонента.
В этом случае, поведение получает возможность следить или менять нормальный ход выполнения компонента.

Свойства поведения также могут быть доступны из
компонента, к которому оно привязано. Свойства включают в себя как открытые, так и
определенные через геттеры и/или сеттеры поведения.
Например, поведение имеет свойство с именем `xyz` и привязано к компоненту
`$a`. Тогда мы можем использовать выражение `$a->xyz` для доступа к свойству.

<div class="revision">$Id: basics.component.txt 2890 2011-01-18 15:58:34Z qiang.xue $</div>