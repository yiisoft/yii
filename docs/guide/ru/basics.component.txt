Компонент
=========
Yii-приложения состоят из компонентов–объектов, созданных согласно спецификациям.
Компонент (component) — это экземпляр класса [CComponent] или производного от него.
Использование компонента в основном включает доступ к его свойствам, а также вызов и обработку его событий.
Базовый класс [CComponent] устанавливает то, как определяются свойства и события.

Свойство компонента
-------------------
Свойство компонента схоже с публичной переменной-членом класса (public member variable).
Мы можем читать или устанавливать его значение. Например:

~~~
[php]
$width=$component->textWidth; // получаем значение свойства textWidth
$component->enableCaching=true; // устанавливаем значение свойства enableCaching
~~~

Для того, чтобы создать свойство компонента необходимо просто объявить публичную переменную в классе компонента.
Более гибкий вариант — определить методы, считывающие (getter) и записывающие (setter) это
свойство, например:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

В приведенном коде определено свойство `textWidth` (имя нечувствительно к регистру), доступное для записи.

При чтении вызывается метод чтения `getTextWidth()`, возвращающий значение свойства.
Соответственно, при записи будет вызван метод записи `setTextWidth()`.
Если метод записи не определен, свойство будет доступно только для чтения, а
при попытке записи будет вызвано исключение. Использование методов чтения и
записи имеет дополнительное преимущество: при чтении или записи значения
свойства могут быть выполнены дополнительные действия (такие как проверка на корректность,
вызов события и др.).

>Note|Примечание: Есть небольшая разница в определении свойства через методы и через простое
объявление переменной. В первом случае имя свойства нечувствительно к регистру,
во втором — чувствительно.


События компонента
------------------
События компонента — это специальные свойства, в качестве значений которых выступают
методы (называемые обработчиками событий). Прикрепление метода к событию приведет к тому, что метод будет вызван
автоматически при возникновении события. Поэтому поведение компонента может быть
изменено совершенно отлично от закладываемого при разработке.

Событие компонента задается путем создания метода с именем, начинающимся на `on`.
Подобно именам свойств, заданных через методы чтения и записи, имена событий
не чувствительны к регистру. Следующий код задает событие `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raiseEvent('onClicked', $event);
}
~~~

где `$event` — это экземпляр класса [CEvent] или производного от него,
представляющего параметр события. К событию можно подключить обработчик, как показано ниже:

~~~
[php]
$component->onClicked=$callback;
~~~

где `$callback` — это корректный callback-вызов PHP (см.
PHP-функцию call_user_func). Это может быть либо глобальная функция, либо метод класса.
В последнем случае вызову должен передаваться массив: `array($object,'methodName')`.

Обработчик события должен быть определен следующим образом:

~~~
[php]
function methodName($event)
{
    …
}
~~~

где `$event` — это параметр, описывающий событие (происходит из вызова `raiseEvent()`).
Параметр `$event` — это экземпляр класса [CEvent] или его производного.
Как минимум, он содержит информацию о том, кто вызвал событие.

Начиная с версии 1.0.10 обработчик события может быть анонимной функцией,
требующей наличия версии PHP 5.3+. Например,

~~~
[php]
$component->onClicked=function($event) {
	…
}
~~~

Если теперь вызвать `onClicked()`, событие `onClicked` будет вызвано (внутри `onClicked()`), и прикрепленный обработчик
события будет запущен автоматически.

К событию может быть прикреплено несколько обработчиков.
При возникновении события обработчики будут вызваны в том порядке,
в котором они были прикреплены к событию.
Если в обработчике необходимо предотвратить вызов последующих обработчиков,
необходимо установить [$event->handled|CEvent::handled] в `true`.


Поведение компонента
------------------

Начиная с версии 1.0.2, к компоненту была добавлена поддержка [примесей (mixin)](http://ru.wikipedia.org/wiki/Mixin)
и теперь к компоненту можно прикрепить одно или несколько поведений. *Поведение* — это объект, чьи методы могут быть «унаследованы»
компонентом, к которому прикреплены, посредством объединения функционала вместо четкой специализации (как в случае обычного наследования класса).
К компоненту можно прикрепить несколько поведений и таким образом получить множественное наследование.

Поведение классов должно реализовывать интерфейс [IBehavior]. Большинство поведений могут быть созданы путем расширения
базового класса [CBehavior]. В случае, если поведение необходимо прикрепить к [модели](/doc/guide/basics.model), его можно
создать на основе класса [CModelBehavior] или класса [CActiveRecordBehavior], который реализует дополнительные,
специфические для модели возможности.

Чтобы воспользоваться поведением, его необходимо прикрепить к компоненту путем вызова метода поведения
[attach()|IBehavior::attach]. Далее мы вызываем метод поведения через компонент:

~~~
[php]
// $name уникально идентифицирует поведения в компоненте
$component->attachBehavior($name,$behavior);
// test() является методом $behavior
$component->test();
~~~

К прикрепленному поведению можно обращаться, как к обычному свойству компонента.
Например, если поведение с именем `tree` прикреплено к компоненту, мы можем получить
ссылку на этот объект поведения следующим образом:

~~~
[php]
$behavior=$component->tree;
// эквивалентно выражению:
// $behavior=$component->asa('tree');
~~~

Поведение можно временно деактивировать таким образом, чтобы его методы были недоступны через компонент.
Например:

~~~
[php]
$component->disableBehavior($name);
// выражение ниже приведет к вызову исключения
$component->test();
$component->enableBehavior($name);
// здесь все будет работать нормально
$component->test();
~~~

В случае, когда два поведения, прикрепленные к одному компоненту, имеют методы с одинаковыми именами,
преимущество будет иметь метод поведения, которое было прикреплено раньше.

Использование поведений совместно с [событиями](/doc/guide/basics.component#component-event) дает дополнительные возможности.
Поведение, прикрепленное к компоненту, может присваивать некоторые свои методы событиям компонента.
В этом случае, поведение получает возможность следить или менять нормальный ход выполнения компонента.

Начиная с версии 1.1.0, свойства поведения также могут быть доступны из
компонента, к которому оно привязано. Свойства включают в себя как открытые, так и
определенные через геттеры и/или сеттеры поведения.
Например, поведение имеет свойство с именем `xyz` и привязано к компоненту
`$a`. Тогда мы можем использовать выражение `$a->xyz` для доступа к свойству.

<div class="revision">$Id: basics.component.txt 2346 2010-08-28 13:12:27Z mdomba $</div>